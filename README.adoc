= K101 - Nodejs-Express
:author: Hafid Haddouti
:toc: left
:toclevels: 4

Kabanero 101 - nodejs-express example used for workshops

toc::[]

== Overview
  
== Steps

For any step exists an own git tag.

=== Prerequisites

* OCPv4 with Kabanero 0.4.0
* Appsody 0.4.5 (0.5.3)

=== Install Appsody

Use the following instruction to install Appsody

* Set env variable with the Appsody version `export AS_VERSION=0.5.3`
* Download and install Appsody from GitHub Release page
** Ubuntu: 
*** Download: `mkdir -p /tmp/appsody && cd /tmp/appsody && wget https://github.com/appsody/appsody/releases/download/${AS_VERSION}/appsody_${AS_VERSION}_amd64.deb`
*** Install: `sudo apt install -f appsody_${AS_VERSION}_amd64.deb`
** MacOS: 
*** `brew install https://raw.githubusercontent.com/appsody/homebrew-appsody/test0.4.5797/appsody.rb`
*** `brew install appsody/appsody/appsody`
** Windows: 
*** Download and extract: `https://github.com/appsody/appsody/releases/download/${AS_VERSION}/appsody-${AS_VERSION}-windows.tar.gz`
*** Execute `appsody-setup.bat`

=== Configure Appsody

Appsody use different repositories to retrieve the stacks/templates.
The course base on the Kabanero Collections. For this add the Kabanero Collection to the local Appsody repositories.

* Set env for Kabanero version: `export K_VERSION=0.4.0`
* Add the Kabanero Collection: `appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/${K_VERSION}/kabanero-index.yaml`
* Verify which stacks are available from Kabanero Collection repo: `appsody list kabanero`
* Set Kabanero Collection repo as default repo: `appsody repo set-default kabanero`
* Verify the list of supported Appsody repos, including the default one: `appsody repo list`

It is advisable to have on the local and remote env (OpenShift cluster) the same Kabanero Collection version configured.
The Kabanero Collection is configured in the `Kabanero CustomResource` object.

Verify that the same version of the Kabanero Collection is used. Login in OpenShift Cluster and check the Kabanero CR

`oc get kabanero -n kabanero -o yaml`

analyse the value of the field `spec.collections.repositories.url` and if your target namespace is observed/listed in `spec.targetNamespaces`.


.Helpful links
----

# Tekton dashboard
td=$(oc get routes tekton-dashboard -n tekton-pipelines -o jsonpath='{.spec.host}') && echo "http://$td:80"

# kAppNav UI
td=$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}') && echo "https://$td/kappnav-ui/"

----

=== step_00: Init

Initial the project.

.Overview
* Intro in Appsody
* Create the project using the `nodejs-express` stack from Kabanero Collection
* Run the application
* Call link:http://localhost:3000/[]
* Stop the app/container with `STRG+C` in the terminal

.Appsody overview
----

$ appsody repo list

NAME     	URL
*kabanero	https://github.com/kabanero-io/collections/releases/download/0.4.0/kabanero-index.yaml
appsodyex	https://github.com/appsody/stacks/releases/latest/download/experimental-index.yaml
incubator	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml

$ appsody list

REPO    	ID               	VERSION  	TEMPLATES        	DESCRIPTION
kabanero	java-microprofile	0.2.19   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
kabanero	java-spring-boot2	0.3.18   	*default, kotlin 	Spring Boot using OpenJ9 and Maven
kabanero	nodejs           	0.2.6    	*simple          	Runtime for Node.js applications
kabanero	nodejs-express   	0.2.8    	scaffold, *simple	Express web framework for Node.js
kabanero	nodejs-loopback  	0.1.6    	*scaffold        	LoopBack 4 API Framework for Node.js
----

Appsody Stacks, e.g. link:https://github.com/appsody/stacks/tree/master/incubator/nodejs-express[nodejs-express] compared to same stack option from Kabanero Collection: link:https://github.com/kabanero-io/collections/tree/master/incubator/nodejs-express[nodejs-express].


.Create project structure
----
$ mkdir k101-nodejs-express & cd k101-nodejs-express
$ appsody init kabanero/nodejs-express

$ tree -a

.
├── .appsody-config.yaml
├── .gitignore
├── .vscode
│   ├── launch.json
│   └── tasks.json
├── app.js
├── package-lock.json
├── package.json
└── test
    └── test.js

2 directories, 8 files
----

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000


$ docker ps | grep kabanero

$ appsody stop
----

.Test Endpoints
* Home: link:http://localhost:3000[]
* Health: link:http://localhost:3000/health[]
* Liveness: link:http://localhost:3000/live[]
* Readiness: link:http://localhost:3000/ready[]
* Prometheus Metrics: link:http://localhost:3000/metrics[]
* Dashboard: link:http://localhost:3000/appmetrics-dash[]


.Verification
* Check the content of the project and compare them with the link:https://github.com/kabanero-io/collections/tree/master/incubator/nodejs-express/templates/simple[template].
* See that a base docker image is now available `docker images | grep nodejs-express`
* Check the endpoints

.Summary
* New project created using Appsody stack `nodejs-express` from the Kabanero Collections
* Application is runnable
* Application/Stack is cloud-native (ready)
* No points of contact with Docker, although it is used in the background.

=== step_01: Code changes

Change the code and see immediately the modification online.

.Overview
* Start the app
* modify the `app.js` and add a new endpoint
* Call the new endpoint link:http://localhost:3000/echo/test-user[]
* Stop the app/container with `STRG+C` in the terminal

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000
----

.Add new endpoint with random delay in processing, file: app.js
[source,javascript]
----
const sleep = (waitTimeInMs) => new Promise(resolve => setTimeout(resolve, waitTimeInMs));

app.get('/echo/:val', (req, res) => {
  let val = req.params.val;

  let delay = Math.floor(1000 * (Math.random() * 5)); 
  sleep(delay).then(() => {
    res.send("Echo: " + val + "; delay=" + delay);
  })
  
});

// before
// module.exports.app = app;
----

Verify the terminal with the Appsody log output to see the monitored file change. Appsody restarts the node process with the latest change.

.Appsody log output
----
[Container] [ControllerDebug] File watch event detected for:  FILE "app.js" WRITE [/project/user-app/app.js]
...
[Container] [ControllerDebug] New process created with pid 57
[Container]
[Container] > nodejs-express@0.2.8 start /project
[Container] > node server.js

----

Verify also that the same docker container is still running

.Check docker process
----
$ docker ps | grep kabanero

ab14a8692277        kabanero/nodejs-express:0.2   "/.appsody/appsody-c…"   7 minutes ago       Up 7 minutes        0.0.0.0:3000->3000/tcp, 0.0.0.0:8080->8080/tcp, 0.0.0.0:9229->9229/tcp   k101-nodejs-express-dev
----

.Check the log from the docker process (similar to the log output from Appsody terminal)
----
$ docker logs -f $(docker ps | grep kabanero | awk '{print $1}')
----

.Verification
* Docker container is still the same, also after code changes. Check CREATED / STATUS from `docker ps`
* Execute the new endpoint link:http://localhost:3000/echo/Ich-Check-Das[]
* ...and see the the request(s) in the Dashboard


.Summary
* Fast ramp-up. New nodejs-express created without taking care about project initialization, structure, dependencies
* Undisturbed development without (manual) server restarts
* Container support out of the box, without touching Dockerfile or Docker commands

=== step_02: Codewind integration

Integrate in Codewind and test and debug the flow including monitoring and performance.

.Prerequisites
* VSCode with Codewind plugin, use the marketplace and search for `Codewind`
* Consider that the project must be located under `$HOME/codewind-workspace`

.Steps
* Add the existing project to Codewind. In Codewind view, select *Projects* > *Add Existing Project* and select the directory with our project
* Open App: use the context menu in Codewind for the project, to open app in browser
* Open Shell: to get a shell into the container
* Show all logs: to get all logs from the container in the VSCode output view
* Open Application Monitor: to open in the browser the monitor page
* Open Performance Dashboard: to open the performance page
* Create test case
** Edit load run settings
*** Path: `/echo/pf1`
*** Save
** Run Load Test
*** set a name and execute the test. repeat this multiple times
** Observe the Application Monitor
* Restart the app in Debug Mode: Select in Codewind view `Restart in Debug Mode` (consider the status bar color of VSCode: orange for debug mode)
** Set a break point in `app.js`
** Open App: because after restarting is a new port exposed
** Make a request `/echo/debug`
** Go line by line in VSCode Debug perspective, observe and watch variables
** Restart in Run Mode

.Summary
* Project provides out of the box multiple features like: Application Monitoring, Performance testing...all without explicitly configuration
* IDE integration in VSCode is helpful and hides any Appsody commands
* Debugging also out of the box supported

NOTE: The features like Application Monitoring and Performance test support is dependent from the used Appsody stack. Currently not all stacks support this features.

=== step_03: Manual Deployment

Deploy the application into a OCP Cluster (current OCPv4.2) using manual steps.

.Prerequisites
* OCPv4.2 cluster
* `oc` cli installed on local machine
* Kabanero (v0.4.0) Foundation installed, see link:https://kabanero.io/docs/ref/general/installation/installing-kabanero-foundation.html[]. Consider to checkout the *0.4.0* branch!
* Set env var for Container Registry URL: `export CR_URL=<the OpenShift URL>`
* Set env var for own project name: `export PRJ_NAME=<your-project-name>`
* Add the domain of the Container Registry to the docker daemon config to avoid insecure error messages
.${HOME}/.docker/daemon.json - Example with two Container Registry domains
[javascript]
----
{
    "bip":"172.18.0.1/24",
    "debug": true,
    "storage-driver": "overlay",
    "insecure-registries": [
        "registry.test.training.katacoda.com:4567", 
        "image-registry-openshift-image-registry.2886795280-80-shadow04.environments.katacoda.com"]
}
----

.Steps
* Connect to the OCP cluster
** Get the CLI command with token from the OCP Application console
** `oc login https://master.com:443 --token=....`
* Login to Container Registry
** If the Registry is insecure, you receive e.g. following error message `Error response from daemon: Get https://docker-registry-..example.com/v2/: x509: certificate signed by unknown authority`. 
** Add the domain in the Docker config for insecure registries.
** Login to OCP registry: `docker login -u $(oc whoami) -p $(oc whoami -t) http://${CR_URL}`
* Build a stable version 

* Tagging
** Tag and push the version: `appsody build -t ${PRJ_NAME}/k101-nodejs-express:v0.1 --push-url ${CR_URL}`
** Verify that an ImageStream is created
* Deployment
** Create the project in OCP: `oc new-project ${PRJ_NAME}`, if not available
** Deploy into the cluster using the internal image: `appsody deploy -t docker-registry.default.svc:5000/${PRJ_NAME}/k101-nodejs-express:v0.1 --namespace ${PRJ_NAME} --no-build`
* Verification
** Call the endpoint of the deployed app
** Call kAppNav to see the deployed app


.Build
----
$ docker login -u $(oc whoami) -p $(oc whoami -t) https://${CR_URL}
Login Succeeded

$ appsody build -t ${PRJ_NAME}/k101-nodejs-express:v0.1 --push-url ${CR_URL}

...
Built docker image k101-nodejs-express:v0.1
[Docker] Successfully tagged image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Pushing image image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Built docker image image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Running command: docker create --name test3-extract docker.io/kabanero/nodejs-express:0.2
Running command: docker cp test3-extract:/config/app-deploy.yaml /Users/haddouti/codewind-workspace/test3/app-deploy.yaml
Running command: docker rm test3-extract -f
Created deployment manifest: /Users/haddouti/codewind-workspace/test3/app-deploy.yaml

$ cat app-deploy.yaml

...
spec:
  applicationImage: docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1
  createKnativeService: false
  expose: true
  livenessProbe:
    failureThreshold: 12
    httpGet:
      path: /live
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 2
...

$ oc get is -n ${PRJ_NAME}
NAME                  IMAGE REPOSITORY                                                              TAGS   UPDATED
k101-nodejs-express   image-registry.openshift-image-registry.svc:5000/demo00/k101-nodejs-express   v0.1   3 minutes ago
----

.Deploy
----
$ oc new-project ${PRJ_NAME}

Now using project "demo-express" on server "https://master.com:443".

$ appsody deploy -t image-registry.openshift-image-registry.svc:5000/${PRJ_NAME}/k101-nodejs-express:v0.1 --namespace ${PRJ_NAME} --no-build

Extracting project from development environment
Pulling docker image kabanero/nodejs-express:0.2
Running command: docker pull kabanero/nodejs-express:0.2
0.2: Pulling from kabanero/nodejs-express
Digest: sha256:ae05d5a746aa0f043ce589fa73fe8139dc5d829787a8433f9fa01ccd83b9fadb
Status: Image is up to date for kabanero/nodejs-express:0.2
docker.io/kabanero/nodejs-express:0.2
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
...

Running command: kubectl get route k101-nodejs-express -o jsonpath={.status.ingress[0].host} --namespace demo-express
Deployed project running at k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com

$ oc get route -n ${PRJ_NAME}
NAME                  HOST/PORT                                                        PATH   SERVICES              PORT       TERMINATION   WILDCARD
k101-nodejs-express   k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com          k101-nodejs-express   3000-tcp                 None

$ curl "http://$(oc get route k101-nodejs-express -n ${PRJ_NAME} -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681
----


.Deployment verification
----
$ curl "http://$(oc get route k101-nodejs-express -n demo-express -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681

$ echo "https://$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}')/kappnav-ui"
https://kappnav-ui-service-kappnav.apps.bcaf.example.opentlc.com/kappnav-ui/

$ oc get application
NAME                  AGE
k101-nodejs-express   51m

$ oc get application k101-nodejs-express -o yaml

$ oc describe application k101-nodejs-express

$ oc get pods
NAME                                  READY   STATUS    RESTARTS   AGE
appsody-operator-5b4bbc8c44-7gxt6     1/1     Running   0          52m
k101-nodejs-express-ffbf86dc4-gvhnn   1/1     Running   0          16m
----


.Summary
* For deployment we enter the Appsody world (again), will be optimized in near future
* Deployment handled from an `AppsodyApplication` operator and creates all resources, incl. routes
* `Application` resource also is installed holding all meta information to the application
* Again no Docker contact points, except the tag name.

=== step_04: Deployment with Pipeline

Deploy the application into a OCP Cluster (current OCPv3.11) using Tekton Pipelines.

Kabanero (Foundation) provides a set of predefined pipelines for the different stacks.
For our project is the pipeline `nodejs-express-build-deploy-pipeline` relevant, which builds and deploy the project. Input is the Git repo and pipeline results in a running container.

Kabanero deploys in the same namespace where Kabanero CR is deployed, usually `kabanero`. To support other target namespaces enhance the Kabanero CR and add in the `app-deploy.yaml` the target namespace.

.Prerequisites
* OCP Cluster
* Kabanero Foundation installed, incl. Tekton


.Steps
* Create GitHub Personal Access Token
** Enter GitHub > Profile *Settings* > *Developer Settings* > *Personal Access Tokens*. *Generate new token*
*** Set name
*** Set permission: `admin:repo_hook`
*** Remember the token!
* Configure Kabanero to support further namespaces
** Enhance Kabanero CR with the list of target namespaces
** Adjust the Appsody deployment manifest file holding the target namespace
* Configure Tekton to access GitHub
** Call Tekton Dashboard `echo "http://$(oc get routes tekton-dashboard -n kabanero -o jsonpath='{.spec.host}')"`
** Select *Secrets* and click *Add Secret*
** Set fields:
*** Name: github
*** Namespace: kabanero
*** Access To: Git server
*** Username: your Git username
*** Password/Token: The generated Git PAT
*** Service Account: kabanero-operator
*** Server URL: https://github.com
* Configure Tekton Webhook for GitHub
** Call Tekton Dashboard
** Select *Webhooks*
** Set fields
*** Name: demo-express-webhook
*** Repository URL: The URL to the Git repo, e.g. https://github.com/haf-tech/k101-nodejs-express.git
*** Access Token: Press + and define a name and the Github PAT
*** Namespace: kabanero
*** Pipeline: select the pipeline, here `nodejs-express-build-deploy-pipeline`
*** Service Account: kabanero-operator
*** Docker Registry: e.g. the internal one with the namespace, `image-registry.openshift-image-registry.svc:5000/demo-express`
*** Create.
*** This will trigger a WebHook creation in GitHub. (*tbd*)
* Create the project/namespace if not done `demo-express`, before pushing the first image to the project.
* Test Webhook Integration: manual trigger
** Create the PipelineResources for git repo and docker image
** Create a PipelineRun using the Pipeline `nodejs-express-build-deploy-pipeline` with the new created resources
** Watch the pipeline and task runs: `oc get pipelinerun --all-namespaces --watch` and `oc get taskrun --all-namespaces --watch`
** A script exists with all necessary steps: `manual-tekton-pipelinerun.sh`
* Test Webhook Integration: automatic trigger
** Watch all PipelineRuns `oc get pipelinerun --all-namespaces --watch`
** Make a small change and push it in the Git repo




.Verify Pipelines
----
$ oc get pipeline --all-namespaces
NAMESPACE   NAME                                      AGE
kabanero    java-microprofile-build-deploy-pipeline   1d
kabanero    java-spring-boot2-build-deploy-pipeline   1d
kabanero    nodejs-build-deploy-pipeline              1d
kabanero    nodejs-express-build-deploy-pipeline      1d
kabanero    nodejs-loopback-build-deploy-pipeline     1d
kabanero    pipeline0                                 1d

$ oc get pipeline nodejs-express-build-deploy-pipeline -n kabanero -o yaml

apiVersion: tekton.dev/v1alpha1
kind: Pipeline
metadata:
  annotations:
    manifestival: new
...
  name: nodejs-express-build-deploy-pipeline
  namespace: kabanero
...
spec:
  resources:
  - name: git-source
    type: git
  - name: docker-image
    type: image
  tasks:
  - name: build-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      outputs:
      - name: docker-image
        resource: docker-image
    taskRef:
      name: nodejs-express-build-task
  - name: deploy-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      - name: docker-image
        resource: docker-image
    runAfter:
    - build-task
    taskRef:
      name: nodejs-express-deploy-task
----

.Verify Tasks
----
$ oc get task --all-namespaces
NAMESPACE   NAME                            AGE
kabanero    java-microprofile-build-task    1d
kabanero    java-microprofile-deploy-task   1d
kabanero    java-spring-boot2-build-task    1d
kabanero    java-spring-boot2-deploy-task   1d
kabanero    monitor-result-task             1d
kabanero    nodejs-build-task               1d
kabanero    nodejs-deploy-task              1d
kabanero    nodejs-express-build-task       1d
kabanero    nodejs-express-deploy-task      1d
kabanero    nodejs-loopback-build-task      1d
kabanero    nodejs-loopback-deploy-task     1d
kabanero    pipeline0-task                  1d

$ oc get task nodejs-express-build-task -n kabanero -o yaml
...

$ oc get task nodejs-express-deploy-task -n kabanero -o yaml
...
----

.Create the project and set permissions for image pulling
----
$ oc new-project demo-express

$ oc policy add-role-to-user system:image-puller system:serviceaccount:kabanero:k101-nodejs-express --namespace=demo-express
----


Applications are deployed in the namespace where Kabanero CR is installed. To deploy application to different namespace is a configuration of the target namespace(s) necessary.
For this reason add `spec.targetNamespaces` with a list of relevant namespaces.

.Example for Kabanero CR with additional target namespaces (reduced to the essential)
----
$ oc get kabanero kabanero -n kabanero -o yaml

apiVersion: v1
items:
- apiVersion: kabanero.io/v1alpha1
  kind: Kabanero
  metadata:
    name: kabanero
    namespace: kabanero
  spec:
    appsodyOperator: {}
    collections:
      repositories:
      - activateDefaultCollections: true
        name: central
        url: https://github.com/kabanero-io/collections/releases/download/0.3.0/kabanero-index.yaml
    github: {}
    landing: {}
    targetNamespaces:
    - demo-express
    tekton: {}
    version: 0.3.1
kind: List
----

Create a `app-deploy.yaml` containing the target namespaces and the correct image URL (nevertheless the image URL will be replaced during pipeline deployment)
----
appsody deploy --generate-only -t image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1 -n demo-express
----

.Manual pipeline trigger (see also: ./manual-tekton-pipelinerun.sh)
----

$ cat pipelinerun_add.sh
#!/bin/sh
namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1"

cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: v1
items:
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: docker-image
  spec:
    params:
    - name: url
      value: ${DOCKER_IMAGE}
    type: image
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: git-source
  spec:
    params:
    - name: revision
      value: ${REPO_BRANCH}
    - name: url
      value: ${APP_REPO}
    type: git
kind: List
EOF


$ oc get pipelineresource -n kabanero
NAME           AGE
docker-image   14s
git-source     14s

$ cat pipelinerun_exec.sh

#!/bin/sh

namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1"


cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: tekton.dev/v1alpha1
kind: PipelineRun
metadata:
  name: nodejs-express-build-deploy-pipeline-run-1
  namespace: kabanero
spec:
  pipelineRef:
    name: nodejs-express-build-push-deploy-pipeline
  resources:
  - name: git-source
    resourceRef:
      name: git-source
  - name: docker-image
    resourceRef:
      name: docker-image
  serviceAccount: kabanero-operator
  timeout: 60m
EOF

----




Verify the log of the PipelineRun, find the Pod in `-n kabanero` representing the current PipelineRun and display the logs for one of the sub steps. Each step is own container.
---
step-create-dir-docker-image-l4z85 
step-git-source-git-source-2trnz 
step-assemble-extract 
step-validate-collection-is-active 
step-build step-push step-image-digest-exporter-4lgzc

$ oc logs -f nodejs-express-build-deploy-pipeline-run-1-build-push-tas-nk4f4-pod-1d33c3 -c step-build
---


Additionally is it necessary to add the target namespace in `app-deploy.yaml`
*tbd*


.Summary
* Deployment into Kubernetes/OCP Cluster works 
* Deployment approach independent from the used technology stack of the app
* Do not care which tools or how a build or deployment works

== License

This article is licensed under the Apache License, Version 2.
Separate third-party code objects invoked within this code pattern are licensed by their respective providers pursuant
to their own separate licenses. Contributions are subject to the
link:https://developercertificate.org/[Developer Certificate of Origin, Version 1.1] and the
link:https://www.apache.org/licenses/LICENSE-2.0.txt[Apache License, Version 2].

See also link:https://www.apache.org/foundation/license-faq.html#WhatDoesItMEAN[Apache License FAQ]
.
