= K101 - Nodejs-Express
:author: Hafid Haddouti
:toc: left
:toclevels: 4

Kabanero 101 - nodejs-express example used for workshops

toc::[]

== Overview

This step-by-step instructions provides the explanation to use Kabanero (Appsody + Kabanero Collection + Kabanero Pipeline) to create a new application, build and deploy them into an OpenShift Cluster.

The main structure is that every steps contains the following sections

* Overview of the main steps
* Detailed step description with the commands
* Verification tasks if applicable
* Summary

== Steps

=== Prerequisites

* OCPv4 with Kabanero 0.4.0
* Appsody 0.4.5 (0.5.4)

'''

=== Install Appsody

Use the following instruction to install Appsody

* Set env variable with the Appsody version `export AS_VERSION=0.4.5`
* Download and install Appsody from GitHub Release page
** Ubuntu: 
*** Download: `mkdir -p /tmp/appsody && cd /tmp/appsody && wget https://github.com/appsody/appsody/releases/download/${AS_VERSION}/appsody_${AS_VERSION}_amd64.deb`
*** Install: `sudo apt install -f appsody_${AS_VERSION}_amd64.deb`
** MacOS: 
*** `brew install https://raw.githubusercontent.com/appsody/homebrew-appsody/test0.4.5797/appsody.rb`
*** `brew install appsody/appsody/appsody`
** Windows: 
*** Download and extract: `https://github.com/appsody/appsody/releases/download/${AS_VERSION}/appsody-${AS_VERSION}-windows.tar.gz`
*** Execute `appsody-setup.bat`
* Verify the installation `appsody version`

=== Configure Appsody

Appsody uses different repositories to retrieve the stacks/templates.
The course is based on the Kabanero Collections. For this add the Kabanero Collection to the local Appsody repositories.

* Set env for Kabanero version: `export K_VERSION=0.4.0`
* Add the Kabanero Collection: `appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/${K_VERSION}/kabanero-index.yaml`
* Verify which stacks are available from Kabanero Collection repo: `appsody list kabanero`
* Set Kabanero Collection repo as default repo: `appsody repo set-default kabanero`
* Verify the list of supported Appsody repos, including the default one: `appsody repo list`

It is advisable to have on the local and remote env (OpenShift cluster) the same Kabanero Collection version configured.
The Kabanero Collection is configured in the `Kabanero CustomResource` object.

Verify that the same version of the Kabanero Collection is used. Login in OpenShift Cluster and check the Kabanero CR

`oc get kabanero -n kabanero -o yaml`

analyse the value of the field `spec.collections.repositories.url` and if your target namespace is observed/listed in `spec.targetNamespaces`.

NOTE: To get the OpenShift CLI Access Token. Connect to OpenShift Webconsole > Click on Username at the top right corner > Select `Copy Login Command`

.Helpful links
----

# Tekton dashboard
td=$(oc get routes tekton-dashboard -n tekton-pipelines -o jsonpath='{.spec.host}') && echo "http://$td:80"

# kAppNav UI
td=$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}') && echo "https://$td/kappnav-ui/"

----

'''

=== step_00: Init

Initial the project.

[NOTE]
====
.Overview
* Intro in Appsody
* Create the project using the `nodejs-express` stack from Kabanero Collection
* Run the application
* Call link:http://localhost:3000/[]
* Stop the app/container with `STRG+C` in the terminal
====

.Appsody overview
----

$ appsody repo list

NAME     	URL
*kabanero	https://github.com/kabanero-io/collections/releases/download/0.4.0/kabanero-index.yaml
appsodyex	https://github.com/appsody/stacks/releases/latest/download/experimental-index.yaml
incubator	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml

$ appsody list

REPO    	ID               	VERSION  	TEMPLATES        	DESCRIPTION
kabanero	java-microprofile	0.2.19   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
kabanero	java-spring-boot2	0.3.18   	*default, kotlin 	Spring Boot using OpenJ9 and Maven
kabanero	nodejs           	0.2.6    	*simple          	Runtime for Node.js applications
kabanero	nodejs-express   	0.2.8    	scaffold, *simple	Express web framework for Node.js
kabanero	nodejs-loopback  	0.1.6    	*scaffold        	LoopBack 4 API Framework for Node.js
----

Appsody Stacks, e.g. link:https://github.com/appsody/stacks/tree/master/incubator/nodejs-express[nodejs-express] compared to same stack option from Kabanero Collection: link:https://github.com/kabanero-io/collections/tree/master/incubator/nodejs-express[nodejs-express]. The main difference is the Pipeline support.


.Create project structure
----
$ mkdir k101-nodejs-express & cd k101-nodejs-express
$ appsody init kabanero/nodejs-express

$ tree -a

.
├── .appsody-config.yaml
├── .gitignore
├── .vscode
│   ├── launch.json
│   └── tasks.json
├── app.js
├── package-lock.json
├── package.json
└── test
    └── test.js

2 directories, 8 files
----

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000


$ docker ps | grep kabanero

$ appsody stop
----

.Test Endpoints
* Home: link:http://localhost:3000[]
* Health: link:http://localhost:3000/health[]
* Liveness: link:http://localhost:3000/live[]
* Readiness: link:http://localhost:3000/ready[]
* Prometheus Metrics: link:http://localhost:3000/metrics[]
* Dashboard: link:http://localhost:3000/appmetrics-dash[]


.Verification
* Check the content of the project and compare them with the link:https://github.com/kabanero-io/collections/tree/master/incubator/nodejs-express/templates/simple[template].
* See that a base docker image is now available `docker images | grep nodejs-express`
* Check the endpoints

[NOTE]
====
.Summary
* New project created using Appsody stack `nodejs-express` from the Kabanero Collections
* Application is runnable
* Application/Stack is cloud-native (ready)
* No points of contact with Docker, although it is used in the background.
====

'''

=== step_01: Code changes

Change the code and see immediately the modification online.

[NOTE]
====
.Overview
* Start the app
* modify the `app.js` and add a new endpoint
* Call the new endpoint link:http://localhost:3000/echo/test-user[]
* Stop the app/container with `STRG+C` in the terminal
====

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000
----

.Add new endpoint with random delay in processing, file: app.js
[source,javascript]
----
const sleep = (waitTimeInMs) => new Promise(resolve => setTimeout(resolve, waitTimeInMs));

app.get('/echo/:val', (req, res) => {
  let val = req.params.val;

  let delay = Math.floor(1000 * (Math.random() * 5)); 
  sleep(delay).then(() => {
    res.send("Echo: " + val + "; delay=" + delay);
  })
  
});

// before
// module.exports.app = app;
----

Verify the terminal with the Appsody log output to see the monitored file change. Appsody restarts the node process with the latest change.

.Appsody log output
----
[Container] [ControllerDebug] File watch event detected for:  FILE "app.js" WRITE [/project/user-app/app.js]
...
[Container] [ControllerDebug] New process created with pid 57
[Container]
[Container] > nodejs-express@0.2.8 start /project
[Container] > node server.js

----

Verify also that the same docker container is still running

.Check docker process
----
$ docker ps | grep kabanero

ab14a8692277        kabanero/nodejs-express:0.2   "/.appsody/appsody-c…"   7 minutes ago       Up 7 minutes        0.0.0.0:3000->3000/tcp, 0.0.0.0:8080->8080/tcp, 0.0.0.0:9229->9229/tcp   k101-nodejs-express-dev
----

.Check the log from the docker process (similar to the log output from Appsody terminal)
----
$ docker logs -f $(docker ps | grep kabanero | awk '{print $1}')
----

.Verification
* Docker container is still the same, also after code changes. Check CREATED / STATUS from `docker ps`
* Execute the new endpoint link:http://localhost:3000/echo/Ich-Check-Das[]
* ...and see the the request(s) in the Dashboard

[NOTE]
====
.Summary
* Fast ramp-up. New nodejs-express created without taking care about project initialization, structure, dependencies
* Undisturbed development without (manual) server restarts
* Container support out of the box, without touching Dockerfile or Docker commands
====

'''

=== step_02: Codewind integration (Optional)

Integrate in Codewind and test and debug the flow including monitoring and performance.
This step is optional. 

.Prerequisites
* VSCode with Codewind plugin, use the marketplace and search for `ibm.codewind` (current version in 01.2020: 0.7.0)
** After installation, a `CODEWIND` view will be added to the VSCode window. Right click on `Local` and select `Start Local Codewind`. This will download the relevant Docker images.

.Steps
* Add the existing project to Codewind. In Codewind view, select *Projects* > *Add Existing Project* and select the directory of the project
* Check Codewind features
** `Open App`: use the context menu in Codewind for the project, to open app in browser
** `Open Container Shell`: to get a shell into the container
** `Show all logs`: to get all logs from the container in the VSCode output view
** `Open Application Monitor`: to open in the browser the monitor page
** `Open Performance Dashboard`: to open the performance page
* Create test case
** Edit load run settings
*** Path: `/echo/pf1`
*** Save
** Run Load Test
*** set a name and execute the test. repeat this multiple times
** Observe the Application Monitor
* Restart the app in Debug Mode: Select in Codewind view `Restart in Debug Mode` (consider the status bar color of VSCode: orange for debug mode)
** Set a break point in `app.js`
** Open App: because after restarting is a new port exposed
** Make a request `/echo/debug`
** Go line by line in VSCode Debug perspective, observe and watch variables
** Restart in Run Mode

[NOTE]
====
.Summary
* Project provides out of the box multiple features like: Application Monitoring, Performance testing...all without explicitly configuration
* IDE integration in VSCode is helpful and hides any Appsody commands
* Debugging also out of the box supported
====

IMPORTANT: The features like Application Monitoring and Performance test support is dependent from the used Appsody stack. Currently not all stacks support this features.

'''

=== step_03: Manual Deployment

Deploy the application into a OCP Cluster (current OCPv4.2) using manual steps.

.Prerequisites
* OCPv4.2 cluster
* `oc` cli installed on local machine
* Kabanero (v0.4.0) Foundation installed, see link:https://kabanero.io/docs/ref/general/installation/installing-kabanero-foundation.html[]. Consider to checkout the *0.4.0* branch!
* Add the domain of the Container Registry to the docker daemon config to avoid insecure error messages
.${HOME}/.docker/daemon.json - Example with two Container Registry domains
[javascript]
----
{
    "bip":"172.18.0.1/24",
    "debug": true,
    "storage-driver": "overlay",
    "insecure-registries": [
        "registry.test.training.katacoda.com:4567", 
        "image-registry-openshift-image-registry.2886795280-80-shadow04.environments.katacoda.com"]
}
----

[NOTE]
====
.Overview
* Set the env vars for `CR_URL` and `PRJ_NAME`
* Connect to the OCP cluster
** Get the CLI command with token from the OCP Application console
** `oc login https://master.com:443 --token=....`
* Login to Container Registry
** If the Registry is insecure, you receive e.g. following error message `Error response from daemon: Get https://docker-registry-..example.com/v2/: x509: certificate signed by unknown authority`. 
** Add the domain in the Docker config for insecure registries.
** Login to OCP registry: `docker login -u $(oc whoami) -p $(oc whoami -t) http://${CR_URL}`
* Build a stable version 

* Tagging
** Tag and push the version: `appsody build -t ${PRJ_NAME}/k101-nodejs-express:v0.1 --push-url ${CR_URL}`
** Verify that an ImageStream is created
* Deployment
** Create the project in OCP: `oc new-project ${PRJ_NAME}`, if not available
** Deploy into the cluster using the internal image: `appsody deploy -t docker-registry.default.svc:5000/${PRJ_NAME}/k101-nodejs-express:v0.1 --namespace ${PRJ_NAME} --no-build`
* Verification
** Call the endpoint of the deployed app
** Call kAppNav to see the deployed app
====

TIP: Consider to change the application name in the different commands instead using of `k101-nodejs-express`.

.Prepare the current env context
----
$ export CR_URL=<the External OpenShift URL>

$ export PRJ_NAME=<your-project-name>
----

.Build
----
$ docker login -u $(oc whoami) -p $(oc whoami -t) https://${CR_URL}
Login Succeeded

$ appsody build -t ${PRJ_NAME}/k101-nodejs-express:v0.1 --push-url ${CR_URL}

...
Built docker image k101-nodejs-express:v0.1
[Docker] Successfully tagged image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Pushing image image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Built docker image image-registry-openshift-image-registry.apps.cluster-d0b4.sandbox1891.opentlc.com/demo00/k101-nodejs-express:v0.1
Running command: docker create --name test3-extract docker.io/kabanero/nodejs-express:0.2
Running command: docker cp test3-extract:/config/app-deploy.yaml /Users/haddouti/codewind-workspace/test3/app-deploy.yaml
Running command: docker rm test3-extract -f
Created deployment manifest: /Users/haddouti/codewind-workspace/test3/app-deploy.yaml
----

.Check the Manifest file containing info about image, k8s probes etc
----
$ cat app-deploy.yaml

...
spec:
  applicationImage: docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1
  createKnativeService: false
  expose: true
  livenessProbe:
    failureThreshold: 12
    httpGet:
      path: /live
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 2
...
----

.The Build with push results also in an ImageStream in OCP Cluster
----

$ oc get is -n ${PRJ_NAME}
NAME                  IMAGE REPOSITORY                                                              TAGS   UPDATED
k101-nodejs-express   image-registry.openshift-image-registry.svc:5000/demo00/k101-nodejs-express   v0.1   3 minutes ago
----

With Appsody is also possible to deploy the application into an OpenShift Cluster.
The deploy command also (re-)build the application. New Appsody versions (> 0.5) provides the flag `--no-build` to skip the build sub-step.

NOTE: The Appsody version <0.5 has an issue with the direct pushing of the new generated image to the registry and sets a wrong/external image URL in the manifest file. However the Appsody version >0.5 has an other link:https://github.com/appsody/appsody/issues/827[issue] which is not usable in this walkthrough. For this, please call the `deploy` command, adjust the manifest file, and re-apply the manifest file again.

.Deploy
----
$ oc new-project ${PRJ_NAME}

Now using project "demo-express" on server "https://master.com:443".

# Only for Appsody version > 0.5
$ appsody deploy -t ${CR_URL}/${PRJ_NAME}/k101-nodejs-express:v0.1 --namespace ${PRJ_NAME} --no-build

# For Appsody version < 0.5
$ appsody deploy -t ${CR_URL}/${PRJ_NAME}/k101-nodejs-express:v0.1 --namespace ${PRJ_NAME} --push

Extracting project from development environment
Pulling docker image kabanero/nodejs-express:0.2
Running command: docker pull kabanero/nodejs-express:0.2
0.2: Pulling from kabanero/nodejs-express
Digest: sha256:ae05d5a746aa0f043ce589fa73fe8139dc5d829787a8433f9fa01ccd83b9fadb
Status: Image is up to date for kabanero/nodejs-express:0.2
docker.io/kabanero/nodejs-express:0.2
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
...

Running command: kubectl get route k101-nodejs-express -o jsonpath={.status.ingress[0].host} --namespace demo-express
Deployed project running at k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com
----

.Adjust app-deploy.yaml
* Get the URL of the ImageStream `oc get is -n ${PRJ_NAME}`
* Change the value of `applicationImage` in `app-deploy.yaml` with the URL from the ImageStream. E.g. result `applicationImage: image-registry.openshift-image-registry.svc:5000/demo40/k101-nodejs-express:v0.1`
* Re-apply the manifest file: `oc apply -f app-deploy.yaml -n ${PRJ_NAME}`


.Get the automatically generated route
----
$ oc get route -n ${PRJ_NAME}
NAME                  HOST/PORT                                                        PATH   SERVICES              PORT       TERMINATION   WILDCARD
k101-nodejs-express   k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com          k101-nodejs-express   3000-tcp                 None

$ curl "http://$(oc get route k101-nodejs-express -n ${PRJ_NAME} -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681
----


.Deployment verification
----
$ curl "http://$(oc get route k101-nodejs-express -n demo-express -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681

$ echo "https://$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}')/kappnav-ui"
https://kappnav-ui-service-kappnav.apps.bcaf.example.opentlc.com/kappnav-ui/

$ oc get application -n ${PRJ_NAME}
NAME                  AGE
k101-nodejs-express   51m

$ oc get application -n ${PRJ_NAME} k101-nodejs-express -o yaml

$ oc describe application -n ${PRJ_NAME} k101-nodejs-express

$ oc get pods -n ${PRJ_NAME}
NAME                                  READY   STATUS    RESTARTS   AGE
k101-nodejs-express-ffbf86dc4-gvhnn   1/1     Running   0          16m
----


.Delete application
----
$ appsody deploy delete -n ${PRJ_NAME}

Deleting deployment using deployment manifest app-deploy.yaml
Attempting to delete resource from Kubernetes...
Running command: kubectl delete -f app-deploy.yaml --namespace demo40
Deployment deleted
----

[NOTE]
====
.Summary
* For deployment we enter the Appsody world (again), will be optimized in near future
* Deployment handled from an `AppsodyApplication` operator and creates all resources, incl. routes
* `Application` resource also is installed holding all meta information to the application
* Again no Docker contact points, except the tag name.
====

'''

=== step_04: Manual Deployment with Pipeline

Deploy manually an application into a OCP Cluster (current OCPv4.2) using Tekton Pipelines.

Kabanero (Foundation) provides a set of predefined pipelines for the different stacks.
For our project is the pipeline `nodejs-express-build-deploy-pipeline` relevant, which builds and deploy the project from an existing Git repo. 

Kabanero deploys in the same namespace where Kabanero CR is deployed, usually `kabanero`. To support other target namespaces is the Kabanero CR enhanced, also the manifest file `app-deploy.yaml` contains the target namespace.

For simplicity the following is given:

* Public repository with Kabanero application (this one here)
* Target Namespace is `demo-express`
* No GitHub Secret is needed
* Kabanero is configured to support multiple target namespaces

.Prerequisites
* OCP Cluster
* Kabanero Foundation installed, incl. Tekton
* Public Git repo with Kabanero application

TIP: Consider to replace the Git Repo URL in the Pipeline definition if you will use your own repository. Otherwise imagine you have already pushed your new application and code change to the given Git repo and you will deploy the latest version with Kabanero Pipeline.

[NOTE]
====
.Overview
* Test Pipeline Execution: manual trigger
** Create the PipelineResources for git repo and docker image
** Create a PipelineRun using the Pipeline `nodejs-express-build-deploy-pipeline` with the new created resources
** Watch the pipeline and task runs: `oc get pipelinerun --all-namespaces --watch` and `oc get taskrun --all-namespaces --watch`
** A script exists with all necessary steps: `manual-tekton-pipelinerun.sh`
** Verify the pipeline execution and resulting app
====

.Verify the existing Pipelines
----
$ oc get pipeline --all-namespaces
NAMESPACE   NAME                                      AGE
kabanero    java-microprofile-build-deploy-pipeline   1d
kabanero    java-spring-boot2-build-deploy-pipeline   1d
kabanero    nodejs-build-deploy-pipeline              1d
kabanero    nodejs-express-build-deploy-pipeline      1d
kabanero    nodejs-loopback-build-deploy-pipeline     1d
...
kabanero    pipeline0                                 1d
----

.Check the details of the nodejs-express pipeline
----
$ oc get pipeline nodejs-express-build-push-deploy-pipeline -n kabanero -o yaml

apiVersion: tekton.dev/v1alpha1
kind: Pipeline
metadata:
  annotations:
    manifestival: new
...
  name: nodejs-express-build-push-deploy-pipeline
  namespace: kabanero
...
spec:
  resources:
  - name: git-source
    type: git
  - name: docker-image
    type: image
  tasks:
  - name: build-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      outputs:
      - name: docker-image
        resource: docker-image
    taskRef:
      name: nodejs-express-build-task
  - name: deploy-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      - name: docker-image
        resource: docker-image
    runAfter:
    - build-task
    taskRef:
      name: nodejs-express-deploy-task
----

.Verify the existing Pipeline Tasks
----
$ oc get task --all-namespaces
NAMESPACE   NAME                            AGE
kabanero    java-microprofile-build-task    1d
kabanero    java-microprofile-deploy-task   1d
kabanero    java-spring-boot2-build-task    1d
kabanero    java-spring-boot2-deploy-task   1d
kabanero    monitor-result-task             1d
kabanero    nodejs-build-task               1d
kabanero    nodejs-deploy-task              1d
kabanero    nodejs-express-build-task       1d
kabanero    nodejs-express-deploy-task      1d
kabanero    nodejs-loopback-build-task      1d
kabanero    nodejs-loopback-deploy-task     1d
...
kabanero    pipeline0-task                  1d
----

.Check details of the nodejs-express relevant tasks
----
$ oc get task nodejs-express-build-task -n kabanero -o yaml
...

$ oc get task nodejs-express-deploy-task -n kabanero -o yaml
...
----


You can also use the Tekton Dashboard to verify the Pipeline and Task definitions

* Tekton Dashboard
** Select `Pipelines`, the Info-Button provides the definition
** Select `Tasks`, Info-Button


To execute a Pipeline create two PipelineResource objects, one holding the Git Repo and the other the resulting Docker Image URL.
To avoid any conflicts with other participants contains both resource the project name as prefix.

.Manual pipeline trigger (see also: ./manual-tekton-pipelinerun.sh)
----

$ cat pipelinerun_add.sh
#!/bin/sh
namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/${PRJ_NAME}/k101-nodejs-express:v0.1"

cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: v1
items:
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: ${PRJ_NAME}-docker-image
  spec:
    params:
    - name: url
      value: ${DOCKER_IMAGE}
    type: image
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: ${PRJ_NAME}-git-source
  spec:
    params:
    - name: revision
      value: ${REPO_BRANCH}
    - name: url
      value: ${APP_REPO}
    type: git
kind: List
EOF


$ oc get pipelineresource -n kabanero
NAME           AGE
docker-image   14s
git-source     14s

$ cat pipelinerun_exec.sh

#!/bin/sh

namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/${PRJ_NAME}/k101-nodejs-express:v0.1"


cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: tekton.dev/v1alpha1
kind: PipelineRun
metadata:
  name: ${PRJ_NAME}-nodejs-express-build-push-deploy-pipeline-run-1
  namespace: kabanero
spec:
  pipelineRef:
    name: nodejs-express-build-push-deploy-pipeline
  resources:
  - name: git-source
    resourceRef:
      name: ${PRJ_NAME}-git-source
  - name: docker-image
    resourceRef:
      name: ${PRJ_NAME}-docker-image
  serviceAccount: kabanero-operator
  timeout: 60m
EOF

----




Verify the log of the PipelineRun, find the Pod in `-n kabanero` representing the current PipelineRun and display the logs for one of the sub steps. Each step is own container.

.Commands to retrieve the right pod and display logs from one internal container (representing a step)
----
$ oc project kabanero

$ oc get pipelinerun 
NAME                                              SUCCEEDED   REASON    STARTTIME   COMPLETIONTIME
nodejs-express-build-push-deploy-pipeline-run-3   Unknown     Running   7m58s

$ oc logs -f $(oc get pods | grep $(oc get pipelinerun --no-headers | awk {'print $1'} | grep -v 'Completed') | awk {'print $1'})

Error from server (BadRequest): a container name must be specified for pod nodejs-express-build-push-deploy-pipeline-run-3-build-pus-5fxt5-pod-13ec4b, choose one of: [step-create-dir-docker-image-vgw6f step-git-source-demo00-git-source-vzv7z step-extract step-validate-collection-is-active step-build step-push step-deploy-image step-image-digest-exporter-trdb4] or one of the init containers: [step-credential-initializer-kcp97 create-dir-default-image-output-dgldc step-place-tools]

$ oc logs -f $(oc get pods | grep $(oc get pipelinerun --no-headers | awk {'print $1'}) | awk {'print $1'}) -c step-build
...

----

You can also verify the current PipelineRun in Tekton Dashboard

* Open *Tekton* Dashboard
* Select `PipelineRuns` and select the running item

The application is also available as `Application` resource in the Cluster. Details are available within kAppNav:

* Open the *kAppNav* Dashboard
* Check the applications
* Select the application and verify the corresponding Kubernetes resources like Service, Deployment etc.
* Find the route of the application:
** Select the application
** Click on the `Route` item in the Component listing
** You will be forwarded to the OpenShift detailed view
** Click on the route URL
** add `/echo/ping` to the URL

[NOTE]
====
.Summary
* Deployment into Kubernetes/OCP Cluster works, from Source code 
* Deployment approach independent from the used technology stack of the app
* Do not care which tools or how a build or deployment works
====

'''


== step_05: Automatic Deployment with Pipeline

Deploy the application into a OCP Cluster (current OCPv4.2) using GitHub Webhook.

Wit the help of a GitHub Webhook new PipelineRuns are executed.
The Webhook configuration in Tekton contains the information which Pipeline and Docker Image to be used.

For simplicity the following is given:

* Public repository with Kabanero application (this one here)
* Target Namespace is `demo-express`
* No GitHub Secret is needed
* Kabanero is configured to support multiple target namespaces
* A default Webhook is also configured. Skip the Webhook configuration instruction if you want to re-use it



.Prerequisites
* OCP Cluster
* Kabanero Foundation installed, incl. Tekton
* Public Git repo with Kabanero application

TIP: Consider to replace the Git Repo URL in the Pipeline definition if you will use your own repository. Otherwise imagine you have already pushed your new application and code change to the given Git repo and you will deploy the latest version with Kabanero Pipeline.

[NOTE]
====
.Overview
* Test Pipeline Execution: triggered by Webhook
** Create a GitHub PAT
** Create in Tekton a Webhook, this will register the Webhook in the GitHub repo
** Push a change and watch the pipeline execution
====



.Overview
* Create GitHub Personal Access Token
** Enter GitHub > Profile *Settings* > *Developer Settings* > *Personal Access Tokens*. *Generate new token*
*** Set name
*** Set permission: `admin:repo_hook`
*** Remember the token!
* Configure Tekton Webhook for GitHub
** Call Tekton Dashboard `echo "http://$(oc get routes tekton-dashboard -n kabanero -o jsonpath='{.spec.host}')"`
** Select *Webhooks*
** Set fields:
*** Name: demo-express-webhook
*** Repository URL: The URL to the Git repo, e.g. https://github.com/haf-tech/k101-nodejs-express.git
*** Access Token: Press + and define a name and the Github PAT
*** Namespace: kabanero
*** Pipeline: select the pipeline, here `nodejs-express-build-deploy-pipeline`
*** Service Account: kabanero-operator
*** Docker Registry: e.g. the internal one with the namespace, `image-registry.openshift-image-registry.svc:5000/demo-express`
*** Create.
*** This will trigger a WebHook creation in GitHub.
** Verify the WebHook in GitHub
*** Select repo in GitHub
*** Select Settings > Webhook and the new created Webhook item
*** Scroll to the bottom and check the result of the last Webhook Execution
*** If error, redeliver and see if status code is `200`. The first initialization can take approx 5min.
* Create the project/namespace if not done `demo-express`, before pushing the first image to the project.
* Test Webhook Integration: automatic trigger
** Watch all PipelineRuns `oc get pipelinerun --all-namespaces --watch`
** Make a small change and push it in the Git repo
*** Check always the Tekton dashboard under PipelineRun first, if the Webhook received or not, even if Github says there was an error like Timeout.


[NOTE]
====
.Summary
* Triggering a deployment from Source control is also supported
* End-2-End process from Git commit until deployment into a cluster is covered
====

'''



== step_10 DRAFT

.Overview
* Create GitHub Personal Access Token
** Enter GitHub > Profile *Settings* > *Developer Settings* > *Personal Access Tokens*. *Generate new token*
*** Set name
*** Set permission: `admin:repo_hook`
*** Remember the token!
* Configure Kabanero to support further namespaces
** Enhance Kabanero CR with the list of target namespaces
** Adjust the Appsody deployment manifest file holding the target namespace
* Configure Tekton to access GitHub
** Call Tekton Dashboard `echo "http://$(oc get routes tekton-dashboard -n kabanero -o jsonpath='{.spec.host}')"`
** Select *Secrets* and click *Add Secret*
** Set fields:
*** Name: github
*** Namespace: kabanero
*** Access To: Git server
*** Username: your Git username
*** Password/Token: The generated Git PAT
*** Service Account: kabanero-operator
*** Server URL: https://github.com
* Configure Tekton Webhook for GitHub
** Call Tekton Dashboard
** Select *Webhooks*
** Set fields
*** Name: demo-express-webhook
*** Repository URL: The URL to the Git repo, e.g. https://github.com/haf-tech/k101-nodejs-express.git
*** Access Token: Press + and define a name and the Github PAT
*** Namespace: kabanero
*** Pipeline: select the pipeline, here `nodejs-express-build-deploy-pipeline`
*** Service Account: kabanero-operator
*** Docker Registry: e.g. the internal one with the namespace, `image-registry.openshift-image-registry.svc:5000/demo-express`
*** Create.
*** This will trigger a WebHook creation in GitHub. (*tbd*)
* Create the project/namespace if not done `demo-express`, before pushing the first image to the project.
* Test Webhook Integration: automatic trigger
** Watch all PipelineRuns `oc get pipelinerun --all-namespaces --watch`
** Make a small change and push it in the Git repo

'''

The following admin tasks are only relevant if not already done. Ask the instructor if the OpenShift environment is configured or not.
For better understanding and administrating these are however listed here:

.Create the project and set permissions for image pulling
----
$ oc new-project ${PRJ_NAME}

$ oc policy add-role-to-user system:image-puller system:serviceaccount:kabanero:k101-nodejs-express --namespace=demo-express
----


Applications are deployed in the namespace where Kabanero CR is installed. To deploy application to different namespace is a configuration of the target namespace(s) necessary.
For this reason add `spec.targetNamespaces` with a list of relevant namespaces.

.Example for Kabanero CR with additional target namespaces (reduced to the essential)
----
$ oc get kabanero kabanero -n kabanero -o yaml

apiVersion: v1
items:
- apiVersion: kabanero.io/v1alpha1
  kind: Kabanero
  metadata:
    name: kabanero
    namespace: kabanero
  spec:
    appsodyOperator: {}
    collections:
      repositories:
      - activateDefaultCollections: true
        name: central
        url: https://github.com/kabanero-io/collections/releases/download/0.3.0/kabanero-index.yaml
    github: {}
    landing: {}
    targetNamespaces:
    - demo-express
    tekton: {}
    version: 0.3.1
kind: List
----

'''

Create a `app-deploy.yaml` containing the target namespaces and the correct image URL (nevertheless the image URL will be replaced during pipeline deployment)
----
appsody deploy --generate-only -t image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1 -n demo-express
----




== License

This article is licensed under the Apache License, Version 2.
Separate third-party code objects invoked within this code pattern are licensed by their respective providers pursuant
to their own separate licenses. Contributions are subject to the
link:https://developercertificate.org/[Developer Certificate of Origin, Version 1.1] and the
link:https://www.apache.org/licenses/LICENSE-2.0.txt[Apache License, Version 2].

See also link:https://www.apache.org/foundation/license-faq.html#WhatDoesItMEAN[Apache License FAQ]
.
