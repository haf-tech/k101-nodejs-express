= K101 - Nodejs-Express
:author: Hafid Haddouti
:toc: left
:toclevels: 4

Kabanero 101 - nodejs-express example used for workshops

toc::[]

== Overview
  
== Steps

For any step exists an own git tag.

=== Prerequisites

* OCPv4 with Kabanero 0.3.1

.Add Kabanero repo
----
$ appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/0.3.1/kabanero-index.yaml

$ appsody list kabanero
----

.Helpful links
----

# Tekton dashboard
td=$(oc get routes tekton-dashboard -n tekton-pipelines -o jsonpath='{.spec.host}') && echo "http://$td:80"

# kAppNav UI
td=$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}') && echo "https://$td/kappnav-ui/"

----

=== step_00: Init

Initial the project.

* Intro in Appsody
* Create the project using the `nodejs-express` stack from Kabanero Collection
* Run the application
* Call link:http://localhost:3000/[]
* Stop the app/container with `STRG+C` in the terminal

.Appsody overview
----

$ appsody repo list

NAME      	URL
*incubator	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml
appsodyex 	https://github.com/appsody/stacks/releases/latest/download/experimental-index.yaml
kabanero  	https://github.com/kabanero-io/collections/releases/download/0.3.0/kabanero-index.yaml

$ appsody list

REPO      	ID                       	VERSION  	TEMPLATES        	DESCRIPTION
appsodyex 	java-spring-boot2-liberty	0.1.10   	*default         	Spring Boot on Open Liberty & OpenJ9 using Maven
appsodyex 	nodejs-functions         	0.1.5    	*simple          	Serverless runtime for Node.js functions
appsodyex 	quarkus                  	0.2.1    	*default         	Quarkus runtime for running Java applications
appsodyex 	rocket                   	0.1.0    	*simple          	Rocket web framework for Rust
appsodyex 	rust                     	0.1.4    	*simple          	Runtime for Rust applications
appsodyex 	vertx                    	0.1.4    	*default         	Eclipse Vert.x runtime for running Java applications
*incubator	java-microprofile        	0.2.19   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
*incubator	java-spring-boot2        	0.3.17   	*default, kotlin 	Spring Boot using OpenJ9 and Maven
*incubator	kitura                   	0.2.2    	*default         	Runtime for Kitura applications
*incubator	nodejs                   	0.2.5    	*simple          	Runtime for Node.js applications
*incubator	nodejs-express           	0.2.9    	scaffold, *simple	Express web framework for Node.js
*incubator	nodejs-loopback          	0.1.7    	*scaffold        	LoopBack 4 API Framework for Node.js
*incubator	python-flask             	0.1.6    	*simple          	Flask web Framework for Python
*incubator	starter                  	0.1.1    	*simple          	Runnable starter stack, copy to create a new stack
*incubator	swift                    	0.2.3    	*simple          	Appsody runtime for Swift applications
kabanero  	java-microprofile        	0.2.18   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
kabanero  	java-spring-boot2        	0.3.15   	*default, kotlin 	Spring Boot using OpenJ9 and Maven
kabanero  	nodejs                   	0.2.5    	*simple          	Runtime for Node.js applications
kabanero  	nodejs-express           	0.2.7    	scaffold, *simple	Express web framework for Node.js
kabanero  	nodejs-loopback          	0.1.5    	*scaffold        	LoopBack 4 API Framework for Node.js
----

Appsody Stacks, e.g. link:https://github.com/appsody/stacks/tree/master/incubator/nodejs-express[nodejs-express] compared to same stack option from Kabanero Collection: link:https://github.com/kabanero-io/collections/tree/master/incubator/nodejs-express[nodejs-express].


.Create project structure
----
$ mkdir k101-nodejs-express & cd k101-nodejs-express
$ appsody init kabanero/nodejs-express

$ tree -a

.
├── .appsody-config.yaml
├── .gitignore
├── .vscode
│   ├── launch.json
│   └── tasks.json
├── app.js
├── package-lock.json
├── package.json
└── test
    └── test.js

2 directories, 8 files
----

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000
----

=== step_01: Code changes

Change the code and see immediately the modification online.

* Start the app
* modify the `app.js` and add a new endpoint
* Call the new endpoint link:http://localhost:3000/echo/test-user[]
* Stop the app/container with `STRG+C` in the terminal

.Start the app
----
$ appsody run -v

...
[Container] App started on PORT 3000
----

.Add new endpoint with random delay in processing
[source,javascript]
----
const sleep = (waitTimeInMs) => new Promise(resolve => setTimeout(resolve, waitTimeInMs));

app.get('/echo/:val', (req, res) => {
  let val = req.params.val;

  let delay = Math.floor(1000 * (Math.random() * 5)); 
  sleep(delay).then(() => {
    res.send("Echo: " + val + "; delay=" + delay);
  })
  
});
----

Verify the terminal with the Appsody log output to see the monitored file change. Appsody restarts the node process with the latest change.

.Appsody log output
----
[Container] [ControllerDebug] File watch event detected for:  FILE "app.js" WRITE [/project/user-app/app.js]
...
[Container] [ControllerDebug] New process created with pid 57
[Container]
[Container] > nodejs-express@0.2.8 start /project
[Container] > node server.js

----

Verify also that the same docker container is still running

.Check docker process
----
$ docker ps | grep k101-nodejs-express

ab14a8692277        kabanero/nodejs-express:0.2   "/.appsody/appsody-c…"   7 minutes ago       Up 7 minutes        0.0.0.0:3000->3000/tcp, 0.0.0.0:8080->8080/tcp, 0.0.0.0:9229->9229/tcp   k101-nodejs-express-dev
----

.Check the log from the docker process (similar to the log output from Appsody terminal)
----
$ docker logs -f $(docker ps | grep k101-nodejs-express | awk '{print $1}')
----

.Summary
* Fast ramp-up. New nodejs-express created without taking care about project initialization, structure, dependencies
* Undisturbed development without (manual) server restarts
* Container support out of the box, without touching Dockerfile or Docker commands

=== step_02: Codewind integration

Integrate in Codewind and test and debug the flow including monitoring and performance.

.Prerequisites
* VSCode with Codewind plugin, use the marketplace and search for `Codewind`
* Consider that the project must be located under `$HOME/codewind-workspace`

.Steps
* Add the existing project to Codewind. In Codewind view, select *Projects* > *Add Existing Project* and select the directory with our project
* Open App: use the context menu in Codewind for the project, to open app in browser
* Open Shell: to get a shell into the container
* Show all logs: to get all logs from the container in the VSCode output view
* Open Application Monitor: to open in the browser the monitor page
* Open Performance Dashboard: to open the performance page
* Create test case
** Edit load run settings
*** Path: `/echo/pf1`
*** Save
** Run Load Test
*** set a name and execute the test. repeat this multiple times
** Observe the Application Monitor
* Restart the app in Debug Mode: Select in Codewind view `Restart in Debug Mode` (consider the status bar color of VSCode: orange for debug mode)
** Set a break point in `app.js`
** Open App: because after restarting is a new port exposed
** Make a request `/echo/debug`
** Go line by line in VSCode Debug perspective, observe and watch variables
** Restart in Run Mode

.Summary
* Project provides out of the box multiple features like: Application Monitoring, Performance testing...all without explicitly configuration
* IDE integration in VSCode is helpful and hides any Appsody commands
* Debugging also out of the box supported

NOTE: The features like Application Monitoring and Performance test support is dependent from the used Appsody stack. Currently not all stacks support this features.

=== step_03: Manual Deployment

Deploy the application into a OCP Cluster (current OCPv3.11) using manual steps.

.Prerequisites
* OCPv3.11 cluster
* `oc` cli installed on local machine
* Kabanero (v0.2.0) Foundation installed, see link:https://kabanero.io/docs/ref/general/installing-kabanero-foundation.html[]. Consider to checkout the *0.2.0* branch!

.Steps
* Connect to the OCP cluster
** Get the CLI command with token from the OCP Application console
** `oc login https://master.com:443 --token=....`
* Build a stable version 
** Login to Container Registry
*** If the Registry is insecure, you receive e.g. following error message `Error response from daemon: Get https://docker-registry-default.apps.bcaf.example.opentlc.com/v2/: x509: certificate signed by unknown authority`. Add the domain in the Docker config for insecure registries.
*** Login to OCP registry: `docker login -u $(oc whoami) -p $(oc whoami -t) http://docker-registry-default.apps.bcaf.example.opentlc.com`
** Tag the version: `appsody build -t k101-nodejs-express:v0.1`
** OPTIONAL
*** Tag the version: `appsody build -t docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1`
*** Generate the manifest file (optional, created with build): `appsody deploy --generate-only -t k101-nodejs-express:v0.1`
* Push the docker image
** `docker push docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1`
** The internal ImageStream use then `docker-registry.default.svc:5000/demo-express/k101-nodejs-express:v0.1`
* Deployment
** Create the project in OCP: `oc new-project demo-express`
** Deploy into the cluster using the internal image: `appsody deploy -t docker-registry.default.svc:5000/demo-express/k101-nodejs-express:v0.1 --namespace demo-express`
* Verification
** Call the endpoint of the deployed app
** Call kAppNav to see the deployed app


.Build
----
$ docker login -u $(oc whoami) -p $(oc whoami -t) https://docker-registry-default....opentlc.com
Login Succeeded

$ appsody build -t docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1

...
Built docker image k101-nodejs-express:v0.1
Running command: docker create --name k101-nodejs-express-extract kabanero/nodejs-express:0.2
Running command: docker cp k101-nodejs-express-extract:/config/app-deploy.yaml /Users/haddouti/codewind-workspace/k101-nodejs-express/app-deploy.yaml
Running command: docker rm k101-nodejs-express-extract -f
Running git command: git version
Running git command: git status -sb
Unable to determine origin to compute repository URL
Running git command: git log -n 1 --pretty=format:'{"author":"%an", "authoremail":"%ae", "sha":"%H", "date":"%cd", "committer":"%cn", "committeremail":"%ce", "message":"%s"}'
Created deployment manifest: /Users/haddouti/codewind-workspace/k101-nodejs-express/app-deploy.yaml

$ cat app-deploy.yaml

...
spec:
  applicationImage: docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1
  createKnativeService: false
  expose: true
  livenessProbe:
    failureThreshold: 12
    httpGet:
      path: /live
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 2
...


$ docker push docker-registry-default.apps.bcaf.example.opentlc.com/demo-express/k101-nodejs-express:v0.1

v0.1: digest: sha256:a299cc21e7e18eebb100556377dff7f25a5283008c34f66add89229c6a08be75 size: 3886

$ oc get is -n demo-express

NAME                  DOCKER REPO                                                         TAGS   UPDATED
k101-nodejs-express   docker-registry.default.svc:5000/demo-express/k101-nodejs-express   v0.1   5 minutes ago
----

.Deploy
----
$ oc new-project demo-express

Now using project "demo-express" on server "https://master.com:443".

$ appsody deploy -t docker-registry.default.svc:5000/demo-express/k101-nodejs-express:v0.1 --namespace demo-express


Extracting project from development environment
Pulling docker image kabanero/nodejs-express:0.2
Running command: docker pull kabanero/nodejs-express:0.2
0.2: Pulling from kabanero/nodejs-express
Digest: sha256:ae05d5a746aa0f043ce589fa73fe8139dc5d829787a8433f9fa01ccd83b9fadb
Status: Image is up to date for kabanero/nodejs-express:0.2
docker.io/kabanero/nodejs-express:0.2
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
...

Running command: kubectl get route k101-nodejs-express -o jsonpath={.status.ingress[0].host} --namespace demo-express
Deployed project running at k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com

$ oc get route -n demo-express
NAME                  HOST/PORT                                                        PATH   SERVICES              PORT       TERMINATION   WILDCARD
k101-nodejs-express   k101-nodejs-express-demo-express.apps.bcaf.example.opentlc.com          k101-nodejs-express   3000-tcp                 None

$ curl "http://$(oc get route k101-nodejs-express -n demo-express -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681
----


.Deployment verification
----
$ curl "http://$(oc get route k101-nodejs-express -n demo-express -o jsonpath='{.spec.host}')/echo/mega"

Echo: mega; delay=2681

$ echo "https://$(oc get routes kappnav-ui-service -n kappnav -o jsonpath='{.spec.host}')/kappnav-ui"
https://kappnav-ui-service-kappnav.apps.bcaf.example.opentlc.com/kappnav-ui/

$ oc get application
NAME                  AGE
k101-nodejs-express   51m

$ oc get application k101-nodejs-express -o yaml

$ oc describe application k101-nodejs-express

$ c get pods
NAME                                  READY   STATUS    RESTARTS   AGE
appsody-operator-5b4bbc8c44-7gxt6     1/1     Running   0          52m
k101-nodejs-express-ffbf86dc4-gvhnn   1/1     Running   0          16m
----


.Summary
* For deployment we enter the Appsody world (again), will be optimized in near future
* Deployment handled from an `AppsodyApplication` operator and creates all resources, incl. routes
* `Application` resource also is installed holding all meta information to the application

=== step_04: Deployment with Pipeline

Deploy the application into a OCP Cluster (current OCPv3.11) using Tekton Pipelines.

Kabanero (Foundation) provides a set of predefined pipelines for the different stacks.
For our project is the pipeline `nodejs-express-build-deploy-pipeline` relevant, which builds and deploy the project. Input is the Git repo and pipeline results in a running container.

Kabanero deploys in the same namespace where Kabanero CR is deployed, usually `kabanero`. To support other target namespaces enhance the Kabanero CR and add in the `app-deploy.yaml` the target namespace.

.Prerequisites
* OCP Cluster
* Kabanero Foundation installed, incl. Tekton


.Steps
* Create GitHub Personal Access Token
** Enter GitHub > Profile *Settings* > *Developer Settings* > *Personal Access Tokens*. *Generate new token*
*** Set name
*** Set permission: `admin:repo_hook`
*** Remember the token!
* Configure Kabanero to support further namespaces
** Enhance Kabanero CR with the list of target namespaces
** Adjust the Appsody deployment manifest file holding the target namespace
* Configure Tekton to access GitHub
** Call Tekton Dashboard `echo "http://$(oc get routes tekton-dashboard -n kabanero -o jsonpath='{.spec.host}')"`
** Select *Secrets* and click *Add Secret*
** Set fields:
*** Name: github
*** Namespace: kabanero
*** Access To: Git server
*** Username: your Git username
*** Password/Token: The generated Git PAT
*** Service Account: kabanero-operator
*** Server URL: https://github.com
* Configure Tekton Webhook for GitHub
** Call Tekton Dashboard
** Select *Webhooks*
** Set fields
*** Name: demo-express-webhook
*** Repository URL: The URL to the Git repo, e.g. https://github.com/haf-tech/k101-nodejs-express.git
*** Access Token: Press + and define a name and the Github PAT
*** Namespace: kabanero
*** Pipeline: select the pipeline, here `nodejs-express-build-deploy-pipeline`
*** Service Account: kabanero-operator
*** Docker Registry: e.g. the internal one with the namespace, `image-registry.openshift-image-registry.svc:5000/demo-express`
*** Create.
*** This will trigger a WebHook creation in GitHub. (*tbd*)
* Create the project/namespace if not done `demo-express`, before pushing the first image to the project.
* Test Webhook Integration: manual trigger
** Create the PipelineResources for git repo and docker image
** Create a PipelineRun using the Pipeline `nodejs-express-build-deploy-pipeline` with the new created resources
** Watch the pipeline and task runs: `oc get pipelinerun --all-namespaces --watch` and `oc get taskrun --all-namespaces --watch`
** A script exists with all necessary steps: `manual-tekton-pipelinerun.sh`
* Test Webhook Integration: automatic trigger
** Watch all PipelineRuns `oc get pipelinerun --all-namespaces --watch`
** Make a small change and push it in the Git repo




.Verify Pipelines
----
$ oc get pipeline --all-namespaces
NAMESPACE   NAME                                      AGE
kabanero    java-microprofile-build-deploy-pipeline   1d
kabanero    java-spring-boot2-build-deploy-pipeline   1d
kabanero    nodejs-build-deploy-pipeline              1d
kabanero    nodejs-express-build-deploy-pipeline      1d
kabanero    nodejs-loopback-build-deploy-pipeline     1d
kabanero    pipeline0                                 1d

$ oc get pipeline nodejs-express-build-deploy-pipeline -n kabanero -o yaml

apiVersion: tekton.dev/v1alpha1
kind: Pipeline
metadata:
  annotations:
    manifestival: new
...
  name: nodejs-express-build-deploy-pipeline
  namespace: kabanero
...
spec:
  resources:
  - name: git-source
    type: git
  - name: docker-image
    type: image
  tasks:
  - name: build-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      outputs:
      - name: docker-image
        resource: docker-image
    taskRef:
      name: nodejs-express-build-task
  - name: deploy-task
    resources:
      inputs:
      - name: git-source
        resource: git-source
      - name: docker-image
        resource: docker-image
    runAfter:
    - build-task
    taskRef:
      name: nodejs-express-deploy-task
----

.Verify Tasks
----
$ oc get task --all-namespaces
NAMESPACE   NAME                            AGE
kabanero    java-microprofile-build-task    1d
kabanero    java-microprofile-deploy-task   1d
kabanero    java-spring-boot2-build-task    1d
kabanero    java-spring-boot2-deploy-task   1d
kabanero    monitor-result-task             1d
kabanero    nodejs-build-task               1d
kabanero    nodejs-deploy-task              1d
kabanero    nodejs-express-build-task       1d
kabanero    nodejs-express-deploy-task      1d
kabanero    nodejs-loopback-build-task      1d
kabanero    nodejs-loopback-deploy-task     1d
kabanero    pipeline0-task                  1d

$ oc get task nodejs-express-build-task -n kabanero -o yaml
...

$ oc get task nodejs-express-deploy-task -n kabanero -o yaml
...
----

.Create the project and set permissions for image pulling
----
$ oc new-project demo-express

$ oc policy add-role-to-user system:image-puller system:serviceaccount:kabanero:k101-nodejs-express --namespace=demo-express
----


Applications are deployed in the namespace where Kabanero CR is installed. To deploy application to different namespace is a configuration of the target namespace(s) necessary.
For this reason add `spec.targetNamespaces` with a list of relevant namespaces.

.Example for Kabanero CR with additional target namespaces (reduced to the essential)
----
$ oc get kabanero kabanero -n kabanero -o yaml

apiVersion: v1
items:
- apiVersion: kabanero.io/v1alpha1
  kind: Kabanero
  metadata:
    name: kabanero
    namespace: kabanero
  spec:
    appsodyOperator: {}
    collections:
      repositories:
      - activateDefaultCollections: true
        name: central
        url: https://github.com/kabanero-io/collections/releases/download/0.3.0/kabanero-index.yaml
    github: {}
    landing: {}
    targetNamespaces:
    - demo-express
    tekton: {}
    version: 0.3.1
kind: List
----

Create a `app-deploy.yaml` containing the target namespaces and the correct image URL (nevertheless the image URL will be replaced during pipeline deployment)
----
appsody deploy --generate-only -t image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1 -n demo-express
----

.Manual pipeline trigger (see also: ./manual-tekton-pipelinerun.sh)
----

$ cat pipelinerun_add.sh
#!/bin/sh
namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1"

cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: v1
items:
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: docker-image
  spec:
    params:
    - name: url
      value: ${DOCKER_IMAGE}
    type: image
- apiVersion: tekton.dev/v1alpha1
  kind: PipelineResource
  metadata:
    name: git-source
  spec:
    params:
    - name: revision
      value: ${REPO_BRANCH}
    - name: url
      value: ${APP_REPO}
    type: git
kind: List
EOF


$ oc get pipelineresource -n kabanero
NAME           AGE
docker-image   14s
git-source     14s

$ cat pipelinerun_exec.sh

#!/bin/sh

namespace=kabanero
APP_REPO=https://github.com/haf-tech/k101-nodejs-express.git
REPO_BRANCH=master
DOCKER_IMAGE="image-registry.openshift-image-registry.svc:5000/demo-express/k101-nodejs-express:v0.1"


cat <<EOF | oc -n ${namespace} apply -f -
apiVersion: tekton.dev/v1alpha1
kind: PipelineRun
metadata:
  name: nodejs-express-build-deploy-pipeline-run-1
  namespace: kabanero
spec:
  pipelineRef:
    name: nodejs-express-build-push-deploy-pipeline
  resources:
  - name: git-source
    resourceRef:
      name: git-source
  - name: docker-image
    resourceRef:
      name: docker-image
  serviceAccount: kabanero-operator
  timeout: 60m
EOF

----




Verify the log of the PipelineRun, find the Pod in `-n kabanero` representing the current PipelineRun and display the logs for one of the sub steps. Each step is own container.
---
step-create-dir-docker-image-l4z85 
step-git-source-git-source-2trnz 
step-assemble-extract 
step-validate-collection-is-active 
step-build step-push step-image-digest-exporter-4lgzc

$ oc logs -f nodejs-express-build-deploy-pipeline-run-1-build-push-tas-nk4f4-pod-1d33c3 -c step-build
---


Additionally is it necessary to add the target namespace in `app-deploy.yaml`
*tbd*


.Summary
* Deployment into Kubernetes/OCP Cluster works 
* Deployment approach independent from the used technology stack of the app
* Do not care which tools or how a build or deployment works

== License

This article is licensed under the Apache License, Version 2.
Separate third-party code objects invoked within this code pattern are licensed by their respective providers pursuant
to their own separate licenses. Contributions are subject to the
link:https://developercertificate.org/[Developer Certificate of Origin, Version 1.1] and the
link:https://www.apache.org/licenses/LICENSE-2.0.txt[Apache License, Version 2].

See also link:https://www.apache.org/foundation/license-faq.html#WhatDoesItMEAN[Apache License FAQ]
.
